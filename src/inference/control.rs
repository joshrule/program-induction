use std::time::Instant;

/// Parameters for running MCMC-based inference mechanisms.
#[derive(Copy, Clone, Debug)]
pub struct Control {
    /// Termination condition: The number of steps to take during inference.
    pub steps: usize,
    /// Termination condition: The number of milliseconds allowed for inference.
    pub runtime: usize,
    /// The number of initial samples to throw away before returning the first sample.
    pub burn: usize,
    /// The number of samples to throw away between returned samples.
    pub thin: usize,
    /// The number of steps without improvement after which to restart the chain.
    pub restart: usize,
    /// The chain's start time.
    pub start: Option<Instant>,
    /// The number of proposals generated by the chain so far.
    pub done_steps: usize,
}

impl Control {
    /// Create a new `Control`.
    pub fn new(steps: usize, runtime: usize, burn: usize, thin: usize, restart: usize) -> Self {
        Control {
            steps,
            runtime,
            burn,
            thin,
            restart,
            done_steps: 0,
            start: None,
        }
    }
    /// Start the chain.
    pub fn start(&mut self) {
        self.start = Some(Instant::now());
        self.done_steps = 0;
    }
    /// Test whether the chain has been started.
    pub fn started(&mut self) -> bool {
        self.start.is_some()
    }
    /// Test whether the chain can continue running.
    pub fn running(&mut self) -> bool {
        match self.start {
            // Not started, so definitely not running
            None => false,
            // Started, and maybe running.
            Some(start_time) => {
                self.done_steps += 1;
                !((self.steps > 0 && self.done_steps >= self.steps)
                    || (self.runtime > 0
                        && start_time.elapsed().as_millis() as usize >= self.runtime))
            }
        }
    }
    /// Make the chain eternal by removing termination conditions.
    pub fn eternal(mut self) -> Self {
        self.steps = 0;
        self.runtime = 0;
        self
    }
    pub fn runtime_ms(&self) -> usize {
        match self.start {
            Some(start) => start.elapsed().as_millis() as usize,
            None => 0,
        }
    }
}
